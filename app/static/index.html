<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>News Trends & Visuals</title>
  <link rel="stylesheet" href="./style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-cloud/build/d3.layout.cloud.min.js"></script>
  <script src="./date-range-spec.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://cdn.jsdelivr.net/npm/flatpickr/dist/l10n/de.js"></script>
</head>
<body>

<!-- Top-Bar -->
<nav class="topbar">
  <button id="filterOpen" aria-label="Filter öffnen">☰ Filter</button>
  <div class="title">📰 News Trends</div>
  <div class="right">
    <input type="text" id="keywordInput" placeholder="🔍 z. B. Klima">
    <button onclick="searchByKeyword()">Suchen</button>
    <button onclick="resetFilters()">Reset</button>
  </div>
</nav>

<!-- Aktive Filter: immer sichtbar -->
<div id="alerts"></div>
<!--  -->
<div id="activeFiltersBar" class="active-filters-bar" aria-live="polite"></div>

<!-- Drawer (Off-Canvas) -->
<aside id="filterDrawer" class="drawer" aria-hidden="true">
  <header class="drawer-header">
    <h3>Filter</h3>
    <button id="drawerClose" aria-label="Filter schließen">✕</button>
  </header>

  <section class="drawer-section">
    <h4>Zeitraum</h4>
    <div class="time-presets">
      <button type="button" data-days="1">1 Tag</button>
      <button type="button" data-days="3">3 Tage</button>
      <button type="button" data-days="7">7 Tage</button>
      <button type="button" data-days="30">30 Tage</button>
      <button type="button" id="btnCustomRange">Benutzerdefiniert…</button>
    </div>

    <!-- index.html – im Bereich "Active Filters" -->
    <div id="active-filters">
      <!-- bestehende Badges ... -->
      <span id="date-range-badge" class="filter-badge" style="display:none">
        <span class="icon">📅</span>
        <span class="label" aria-live="polite"></span>
        <span class="remove" title="Entfernen" aria-label="Zeitraum entfernen">×</span>
      </span>
    </div>

  </section>

  <section class="drawer-section">
    <h4>Kombi-Länge</h4>
    <div class="btnrow" id="ngramButtons">
      <button onclick="setNgram(1)">1 Wort</button>
      <button onclick="setNgram(2)">2er-Kombis</button>
      <button onclick="setNgram(3)">3er-Kombis</button>
    </div>
  </section>

  <section class="drawer-section">
    <h4>Quelle</h4>
    <!-- Nutze dein bestehendes Select mit den gleichen Optionen -->
    <select id="sourceSelect">
      <option value="">-- Alle Quellen --</option>
      <option value="Zeit">Zeit</option>
      <option value="Spiegel">Spiegel</option>
      <option value="Süddeutsche">Süddeutsche</option>
      <option value="Handelsblatt">Handelsblatt</option>
      <option value="Deutschlandfunk">Deutschlandfunk</option>
      <option value="Tagesschau">Tagesschau</option>
      <option value="FAZ">FAZ</option>
      <option value="n-tv">n-tv</option>
      <option value="Focus Politik">Focus Politik</option>
      <option value="Welt">Welt</option>
      <option value="RP Online">RP Online</option>
      <option value="Stern">Stern</option>
      <option value="Tichys Einblick">Tichys Einblick</option>
      <option value="Reitschuster">Reitschuster</option>
      <option value="Unzensuriert">Unzensuriert</option>
      <option value="Achse des Guten">Achse des Guten</option>
      <option value="Anti-Spiegel">Anti-Spiegel</option>
      <option value="Telepolis Politik">Telepolis Politik</option>
      <option value="NachDenkSeiten">NachDenkSeiten</option>
      <option value="Volksverpetzer">Volksverpetzer</option>
      <option value="Krautzone">Krautzone</option>
      <option value="Niggemeier/Übermedien">Niggemeier/Übermedien</option>
      <option value="taz">taz</option>
      <option value="junge Welt">junge Welt</option>
      <option value="NZZ Deutschland">NZZ Deutschland</option>
      <option value="Watson Deutschland">Watson Deutschland</option>
      <option value="Frankfurter Rundschau">Frankfurter Rundschau</option>
      <option value="Bild">Bild</option>
      <option value="Nius">Nius</option>
      <option value="Deutsche Wirtschaftsnachrichten">Deutsche Wirtschaftsnachrichten</option>
      <option value="Manova">Manova</option>
      <option value="Auf1">Auf1</option>
      <option value="RT DE">RT DE</option>
      <option value="Correctiv">Correctiv</option>
      <option value="Netzpolitik.org">Netzpolitik.org</option>
      <option value="Norbert Häring">Norbert Häring</option>
      <option value="Overton-Magazin (Politik)">Overton-Magazin (Politik)</option>
      <option value="Berliner Zeitung (Politik)">Berliner Zeitung (Politik)</option>
      <option value="der Freitag (Politik)">der Freitag (Politik)</option>
      <option value="Makroskop">Makroskop</option>
      <option value="German Foreign Policy">German Foreign Policy</option>
      <option value="Infosperber (Politik)">Infosperber (Politik)</option>
      <option value="TauBlog (Politik)">TauBlog (Politik)</option>
      <option value="Jacobin Deutschland">Jacobin Deutschland</option>
      <option value="Multipolar">Multipolar</option>
      <option value="Junge Freiheit">Junge Freiheit</option>
      <option value="neues deutschland">neues deutschland</option>
      <option value="Blackout News">Blackout News</option>
      <option value="Cicero">Cicero</option>
      <option value="rnd">rnd</option>
      <option value="Alexander Wallasch">Alexander Wallasch</option>
      <option value="Compact">Compact</option>
      <option value="Epoch Times">Epoch Times</option>
      <option value="Blätter für deutsche und internationale Politik">Blätter für deutsche und internationale Politik</option>
    </select>
  </section>

  <section class="drawer-section">
    <label class="teaser-inline">
      <input type="checkbox" id="teaserToggle"> Teaser einbeziehen
    </label>
  </section>

  <footer class="drawer-footer">
    <button id="drawerDone">Fertig</button>
  </footer>
</aside>

<!-- Halbtransparenter Hintergrund beim offenen Drawer -->
<div id="scrim" class="scrim" aria-hidden="true"></div>

   <section id="heroWordcloud">
      <div class="wordcloud-heading">
      </div>
      <div id="wordcloud"></div>
    </section>

<section id="keywordTopAbsoluteSection">
  <h2>📊 Top 30 Keywords nach absoluten Nennungen</h2>
  <div id="keywordTopAbsoluteColumns" class="keyword-columns"></div>
</section>

<section id="blindspotFeed" class="blindspot-feed">
  <h2>🕳️ Blindspot-Feed (Keyword-basiert)</h2>
  <div class="blindspot-grid">
    <div class="blindspot-col" id="feedKritisch">
      <h3>Kaum systemkritisch</h3>
      <ul></ul>
    </div>
    <div class="blindspot-col" id="feedNah">
      <h3>Kaum systemnah</h3>
      <ul></ul>
    </div>
    <div class="blindspot-col" id="feedNational">
      <h3>Kaum nationalistisch</h3>
      <ul></ul>
    </div>
    <div class="blindspot-col" id="feedGlobal">
      <h3>Kaum globalistisch</h3>
      <ul></ul>
    </div>
  </div>
</section>


<section id="keywordTrends" class="trend-section trends--minimal">
  <h2>📈 Dynamische Keyword-Trends</h2>
  <div class="trend-grid" id="trendGrid"></div>
</section>



  <div class="chart-row">
    <div class="chart-box">
      <h2>🧭 Medien-Kompass</h2>
      <canvas id="mediaCompassChart"></canvas>
    </div>
      <div class="chart-box">
        <h2>⏲️ Zeitverlauf der Tags</h2>
        <div id="timelineChartWrap">
          <canvas id="timelineChart"></canvas>
        </div>
      </div>

  </div>



<section class="chart-box" id="keywordSidesBox">
  <h2>🧭 Keyword-Verteilung (X/Y)</h2>

  <!-- Balken -->
  <div id="keywordSides"></div>

  <!-- Heatmap darunter, groß -->
  <div id="keywordHeatMiniWrap"
       style="position:relative;width:100%;height:560px;margin-top:16px;
              border:1px solid #eee;border-radius:12px;background:#fff;overflow:hidden;">
    <svg id="keywordHeatMini" style="position:absolute;inset:0;"></svg>
    <div id="keywordHeatMiniEmpty" class="chart-overlay-empty" style="display:none;">
      Keine Heatmap-Daten
    </div>
  </div>
</section>

  <div id="filteredArticles"></div>

<section id="extremeBubbles" class="bubble-section">
  <h2>🫧 Exklusive Begriffe aus Randmedien</h2>
  <div id="sortControls" class="bias-filter-bar">
    <label for="bubbleSort">Sortierung:</label>
    <select id="bubbleSort" onchange="loadExtremeBubbles()">
      <option value="bias-desc">Bias (hoch → niedrig)</option>
      <option value="bias-asc">Bias (niedrig → hoch)</option>
      <option value="count-desc">Anzahl (hoch → niedrig)</option>
      <option value="count-asc">Anzahl (niedrig → hoch)</option>
    </select>
  </div>


  <div id="extremeKeywordBubbles" class="bubble-container"></div>
</section>

<section class="chart-box" id="keywordChartOverlayBox">
  <h2>🧭 Keyword-Koordinaten & Heatmap</h2>
  <div id="keywordChartOverlayContainer"
      style="position: relative; width: 100%; max-width: 1000px; height: 600px; margin: auto;">
    <svg id="keywordHeatmapOverlay"
        style="position: absolute; top: 0; left: 0; z-index: 100; pointer-events: none;"></svg>

    <canvas id="keywordScatterChart"
            style="z-index: 1000; width: 100%; height: 100%; display: block;"></canvas>
  </div>


</section>






  <!-- Leichtes Modal für Date-Range (wird per JS geöffnet/geschlossen) -->
<div id="customRangeModal" aria-hidden="true" role="dialog" aria-modal="false"
     style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.35); z-index:9999; align-items:center; justify-content:center;">
  <div style="background:#fff; width:min(680px,90vw); border-radius:12px; box-shadow:0 10px 30px rgba(0,0,0,.2);">
    <div style="padding:16px 20px; border-bottom:1px solid #eee; display:flex; justify-content:space-between; align-items:center;">
      <strong>Benutzerdefinierter Zeitraum</strong>
      <button type="button" id="btnRangeClose" aria-label="Schließen" style="font-size:18px; line-height:1;">×</button>
    </div>
    <div style="padding:16px 20px; display:flex; gap:12px; flex-wrap:wrap; align-items:center;">
      <label style="min-width:80px;">Start/Ende</label>
      <input id="fpRange" type="text" placeholder="Wähle Start & Ende…" style="flex:1; min-width:260px; padding:8px 10px;">
      <label><input id="cbIncludeTeaserInRange" type="checkbox"> Teaser berücksichtigen</label>
    </div>
    <div style="padding:12px 20px; display:flex; gap:8px; justify-content:flex-end; border-top:1px solid #eee;">
      <button type="button" id="btnRangeCancel">Abbrechen</button>
      <button type="button" id="btnRangeApply" style="background:#1e40af; color:#fff; border:none; padding:8px 14px; border-radius:8px;">Übernehmen</button>
    </div>
  </div>
</div>



  <script>


    let activeBiasFilter = null;
    let keywordScatterChart = null;
    let keywordTimelineChart = null;
    let mediaCompassChart = null;
    let selectedKeyword = "";

    // Zentrale Filter – eine Quelle der Wahrheit
    const FILTERS = {
      from: null,
      to: null,
      source: null,
      keyword: null,
      teaser: false,
      ngram: 1
    };

    // Kompatibilität: alter Code darf noch "filters" benutzen
    Object.defineProperty(window, 'filters', {
      get() { return FILTERS; },
      set(v) {
        if (v && typeof v === 'object') {
          FILTERS.from    = v.from    ?? FILTERS.from;
          FILTERS.to      = v.to      ?? FILTERS.to;
          FILTERS.source  = v.source  ?? FILTERS.source;
          FILTERS.keyword = v.keyword ?? FILTERS.keyword;
          FILTERS.teaser  = v.teaser  ?? FILTERS.teaser;
          FILTERS.ngram   = v.ngram   ?? FILTERS.ngram;
        }
      }
    });

    window.addEventListener('load', () => {
      // URL -> State
      getFiltersFromURL();

      // URL normalisieren (exactly one of hours / from-to)
      updateURLFromFilters(true);

      // Badge initial setzen
      updateDateRangeBadge();

      // UI sync
      document.getElementById("sourceSelect").value = FILTERS.source || "";
      document.getElementById("keywordInput").value = FILTERS.keyword || "";
      document.getElementById("teaserToggle").checked = !!FILTERS.teaser;

      // Initiale Datenladungen
      loadWordcloud();
      loadMediaCompass();
      loadFilteredArticles();
      loadKeywordTrends();
      loadExtremeBubbles();
      loadTopAbsoluteKeywords();
      loadBlindspotFeed();
    });


  function getFiltersFromURL() {
    const p = new URLSearchParams(location.search);
    const from = p.get('from');
    const to   = p.get('to');

    FILTERS.source  = p.get('source')  || null;
    FILTERS.keyword = p.get('keyword') || null;
    FILTERS.teaser  = p.get('teaser') === '1' || p.get('teaser') === 'true';

    if (from && to) {
      // URL-Werte ggf. auf "jetzt" klemmen (Server verbietet Zukunft)
      const f = new Date(from);
      const t = new Date(to);
      const { from: f2, to: t2 } = clampRangeToNow(f, t);
      FILTERS.from = toLocalIsoWithTZ(f2);
      FILTERS.to   = toLocalIsoWithTZ(t2);
    } else {
      // Standard: 7 Kalendertage bis JETZT (exklusiv)
      const endEx = nowExclusive();
      const defFrom = startOfDay(new Date(endEx.getTime() - 6 * 86400000));
      FILTERS.from = toLocalIsoWithTZ(defFrom);
      FILTERS.to   = toLocalIsoWithTZ(endEx);
    }
  }

  function updateURLFromFilters(replace=false) {
    const p = new URLSearchParams();
    p.set('from', FILTERS.from);
    p.set('to',   FILTERS.to);
    if (FILTERS.source)  p.set('source', FILTERS.source);
    if (FILTERS.keyword) p.set('keyword', FILTERS.keyword);
    if (FILTERS.teaser)  p.set('teaser', '1');
    const url = `?${p.toString()}`;
    replace ? history.replaceState(null,'',url) : history.pushState(null,'',url);
  }


  function buildTimeQuery() {
    if (FILTERS.from && FILTERS.to) {
      return `from=${encodeURIComponent(FILTERS.from)}&to=${encodeURIComponent(FILTERS.to)}`;
    }
    // Fallback: 7 Kalendertage bis JETZT (exklusiv)
    const endEx = nowExclusive();
    const from  = startOfDay(new Date(endEx.getTime() - 6*86400000));
    FILTERS.from = toLocalIsoWithTZ(from);
    FILTERS.to   = toLocalIsoWithTZ(endEx);
    return `from=${encodeURIComponent(FILTERS.from)}&to=${encodeURIComponent(FILTERS.to)}`;
  }


function withTime(urlBase, extraParams = "") {
  const time = buildTimeQuery();
  const sep = urlBase.includes("?") ? "&" : "?";
  return `${urlBase}${sep}${time}${extraParams ? "&" + extraParams : ""}`;
}



async function searchByKeyword(kw = null) {
  const keyword = kw || document.getElementById("keywordInput").value.trim();
  if (!keyword) return;

  filters.keyword = keyword;
  selectedKeyword = keyword;
  updateURLFromFilters(false);

  loadFilteredArticles();
  loadExtremeBubbles();
  renderKeywordTimeline(keyword);
  loadBlindspotFeed();

  // --- NEU/robust ---
  const box = document.getElementById("keywordSides");
  if (!box) return;                  // falls der Container im HTML noch fehlt
  box.innerHTML = "";                // alten Inhalt leeren

  try {
    const sides = await loadKeywordSides(keyword);
    if (sides) {
      renderKeywordSidesBars(box, sides);
      await loadKeywordDensityMini(keyword);   // ← Mini-Heatmap rechts
      // optional: box.scrollIntoView({ behavior: "smooth", block: "start" });
    } else {
      box.textContent = "Keine Daten für dieses Keyword im aktuellen Zeitfenster.";
    }
  } catch (err) {
    console.error(err);
    box.textContent = "Fehler beim Laden der Verteilung.";
    showMiniEmpty("Fehler beim Laden");
  }
}


    function renderHeadlineList(articles) {
      const container = document.getElementById("filteredArticles");
      if (articles.length === 0) {
        container.innerHTML = "<p>Keine Artikel gefunden.</p>";
        return;
      }

      container.innerHTML = `
        <h3>${selectedKeyword ? `Artikel zu "${selectedKeyword}"` : "Artikel"} vom ausgewählten Medium</h3>
        <ul>
          ${articles.map(a => `<li><a href="${a.url}" target="_blank">${a.title}</a></li>`).join("")}
        </ul>
      `;
    }

async function loadFilteredArticles(page = 1) {
  const qs = new URLSearchParams();
  if (FILTERS.source)  qs.set("source", FILTERS.source);
  if (FILTERS.keyword) qs.set("keyword", FILTERS.keyword);
  if (FILTERS.teaser)  qs.set("teaser", "true");
  qs.set("page", String(page));
  // page_size kannst du später paginieren; Standard reicht hier

  const url = withTime("/articles/filtered", qs.toString());
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) {
    document.getElementById("filteredArticles").innerHTML =
      `<div class="empty-state">Fehler beim Laden (${res.status}).</div>`;
    return;
  }
  const data = await res.json();
  renderFilteredArticles(data);
}

function renderFilteredArticles(list) {
  const el = document.getElementById("filteredArticles");
  if (!el) return;

  if (!list || list.length === 0) {
    el.innerHTML = `
      <div class="empty-state">
        Keine Artikel im gewählten Zeitraum.
        <span class="hint">Tipp: Erhöhe den Zeitraum (z. B. 7d) oder entferne Filter.</span>
      </div>`;
    return;
  }

  el.innerHTML = list.map(a => `
    <article class="article-card" style="border:1px solid #e5e7eb;border-radius:10px;padding:12px;margin:10px 0;background:#fff">
      <div class="muted" style="font-size:.85rem">${new Date(a.published_at).toLocaleString('de-DE')}</div>
      <h3 style="margin:.2rem 0 .4rem 0">
        <a href="${a.url}" target="_blank" rel="noopener">${a.title ?? ""}</a>
      </h3>
      ${a.teaser ? `<p class="muted" style="margin:.3rem 0 0 0">${a.teaser}</p>` : ""}
      <div class="muted" style="font-size:.85rem;margin-top:.25rem">${a.source ?? ""}</div>
    </article>
  `).join("");
}

async function loadKeywordTrends() {
  const res = await fetch("/keywords/trending");
  const data = await res.json();

  const grid = document.getElementById("trendGrid");
  grid.innerHTML = "";

  for (const label of ["24h", "72h", "7d", "30d"]) {
    const entry = data[label];
    if (!entry) continue;

    const group = document.createElement("div");
    group.className = "trend-group";

    const heading = document.createElement("h4");
    heading.textContent = label;
    group.appendChild(heading);

    for (const type of ["top", "flop"]) {
      const sublist = document.createElement("div");
      sublist.className = "trend-sublist";

      const h5 = document.createElement("h5");
      h5.textContent = type === "top" ? "🔼 Aufsteiger" : "🔽 Absteiger";
      sublist.appendChild(h5);

      const ul = document.createElement("ul");
      for (const item of entry[type]) {
        const li = document.createElement("li");
        const pctChange = Math.round(item.change * 100); // von Dezimal in %

        li.innerHTML = `
          ${item.word}
          <span class="${pctChange >= 0 ? 'trend-up' : 'trend-down'}">
            (${item.delta >= 0 ? "+" : ""}${item.delta} | ${pctChange >= 0 ? "+" : ""}${pctChange}%)
          </span>
        `;
        li.title = `Aktuell: ${item.delta + (item.delta >= 0 ? "+" : "")} vs. Vorher: ${item.delta - item.delta}`;

        li.onclick = () => searchByKeyword(item.word);
        ul.appendChild(li);
      }

      sublist.appendChild(ul);
      group.appendChild(sublist);
    }

    grid.appendChild(group);
  }
}

async function loadTopAbsoluteKeywords() {
  const qs = new URLSearchParams({
    ngram: String(FILTERS.ngram ?? 1),
    compare_prev: "1"
  });
  if (FILTERS.teaser) qs.set("teaser", "true");
  const res = await fetch(withTime("/keywords/top-absolute", qs.toString()));
  const data = await res.json();

  const container = document.querySelector("#keywordTopAbsoluteColumns");
  container.innerHTML = "";

  // 3 Spalten à 10
  const chunkSize = 10;
  for (let i = 0; i < 3; i++) {
    const chunk = data.slice(i * chunkSize, (i + 1) * chunkSize);

    const colDiv = document.createElement("div");
    colDiv.className = "keyword-column";

    const table = document.createElement("table");
    table.innerHTML = `
      <thead>
        <tr>
          <th>Keyword</th>
          <th>Aktuell</th>
          <th>Δ abs</th>
          <th>Δ %</th>
        </tr>
      </thead>
      <tbody></tbody>
    `;
    const tbody = table.querySelector("tbody");

    chunk.forEach(row => {
      const pctChange = row.change_pct;
      const trendClass = pctChange >= 0 ? "trend-up" : "trend-down";
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td>${row.word}</td>
        <td>${row.current}</td>
        <td class="${trendClass}">${row.delta >= 0 ? "+" : ""}${row.delta}</td>
        <td class="${trendClass}">${pctChange >= 0 ? "+" : ""}${pctChange}%</td>
      `;
      tr.style.cursor = "pointer";
      tr.onclick = () => searchByKeyword(row.word);
      tbody.appendChild(tr);
    });

    colDiv.appendChild(table);
    container.appendChild(colDiv);
  }
}



  // zentrale Refresh-Funktion: alles neu laden, was vom Bias abhängt
  function applyFilters() {
    loadExtremeBubbles();
    loadTopAbsoluteKeywords();
    loadFilteredArticles();
    loadKeywordTrends();
    loadWordcloud();
    loadFilteredMediaCompass();
    loadBlindspotFeed();
    updateFilterDisplay();

  }

  // Setter für den Bias-Filter: setzt den Filter und triggert die Aktualisierung
  function setBiasFilter(filterName) {
    activeBiasFilter = filterName || null;
    // (Optional: Buttons visuell markieren)
    try {
      document.querySelectorAll('#biasFilters button').forEach(btn => {
        btn.classList.toggle('active', btn.textContent.toLowerCase().includes(filterName ?? 'alle'));
      });
    } catch (_) {}
    applyFilters();
  }

  // EINZIGE Version der Prüf-Funktion
  function biasPassesFilter(bias) {
    // Kein aktiver Filter → alles zulassen
    if (!activeBiasFilter) return true;

    // Aktiver Filter → nur Elemente mit gültigem Bias zulassen
    if (!bias || !Number.isFinite(bias.x) || !Number.isFinite(bias.y)) return false;

    const { x, y } = bias;

    switch (activeBiasFilter) {
      case 'systemkritisch':   return x <= -0.1;
      case 'systemnah':        return x >=  0.1;
      case 'globalistisch':    return y >=  0.1;
      case 'nationalistisch':  return y <= -0.1;
      default:                 return true;
    }
  }

function setNgram(n){
  filters.ngram = n;
  loadWordcloud();
  loadFilteredMediaCompass();
  loadTopAbsoluteKeywords();
  loadBlindspotFeed();
  updateFilterDisplay && updateFilterDisplay();
}

const ngramBtns = () => Array.from(document.querySelectorAll('#ngramButtons button'));
function markActiveNgram(n){
  try {
    ngramBtns().forEach(b => b.classList.remove('is-active'));
    const labels = {1:'1 Wort', 2:'2er-Kombis', 3:'3er-Kombis'};
    const btn = ngramBtns().find(b => b.textContent.trim() === labels[n]);
    if (btn) btn.classList.add('is-active');
  } catch(_) {}
}

// Beim Setzen auch markieren
const _setNgram = window.setNgram || setNgram;
window.setNgram = function(n){
  _setNgram(n);
  markActiveNgram(n);
};

// Initial markieren nach Load
window.addEventListener('load', () => markActiveNgram(filters.ngram));


  async function loadKeywordSides(word) {
    const extra = `word=${encodeURIComponent(word)}` + (FILTERS.teaser ? "&teaser=true" : "");
    const url = withTime("/keywords/sides", extra);
    const res = await fetch(url);
    if (!res.ok) return null;
    return res.json();
  }



  function renderKeywordSidesBars(container, data) {
  container.innerHTML = "";
  const wrap = document.createElement("div");
  wrap.className = "spectrum";

  const makeBar = (axisCounts, leftKey, rightKey, labelText) => {
    const total = axisCounts.total || 1;

    const row   = document.createElement("div"); row.className = "spectrum__row";
    const label = document.createElement("div"); label.className = "spectrum__label";
    label.textContent = labelText;

    const bar   = document.createElement("div"); bar.className = "spectrum__bar";

    const parts = [
      { cls: "spectrum__seg spectrum__seg--left",   key: leftKey,  val: axisCounts[leftKey] },
      { cls: "spectrum__seg spectrum__seg--center", key: "neutral", val: axisCounts.neutral },
      { cls: "spectrum__seg spectrum__seg--right",  key: rightKey, val: axisCounts[rightKey] },
    ];

    parts.forEach(p => {
      const seg = document.createElement("div");
      seg.className = p.cls;
      seg.style.flex = String(p.val);                        // Proportionen
      seg.style.minWidth = p.val === 0 ? "0px" : "2px";      // dünne Segmente sichtbar halten
      const pct = Math.round((p.val / total) * 100);
      seg.textContent = `${p.key === "neutral" ? "C" : p.key} ${pct}%`;
      bar.appendChild(seg);
    });

    row.appendChild(label);
    row.appendChild(bar);
    return row;
  };

  wrap.appendChild(makeBar(data.counts.x, "kritisch", "nah", "Systemkritisch — Neutral — Systemnah"));
  if (data.blindspots?.x) {
    const badge = document.createElement("div");
    badge.className = "spectrum__badge";
    badge.textContent = `Blindspot (X): ${data.blindspots.x}`;
    wrap.appendChild(badge);
  }

  wrap.appendChild(makeBar(data.counts.y, "national", "global", "Nationalistisch — Neutral — Globalistisch"));
  if (data.blindspots?.y) {
    const badge = document.createElement("div");
    badge.className = "spectrum__badge";
    badge.textContent = `Blindspot (Y): ${data.blindspots.y}`;
    wrap.appendChild(badge);
  }

  container.appendChild(wrap);
}



async function loadExtremeBubbles() {
  const bubblesRes = await fetch(withTime("/keywords/extreme-bubble"));
  const bubbleData = await bubblesRes.json();
  const biasRes = await fetch(withTime("/keywords/bias-vector"));
  const biasData = await biasRes.json();

  const container = document.getElementById("extremeKeywordBubbles");
  container.innerHTML = "";

  const sortMode = getSelectedBubbleSort(); // z. B. "bias-desc"

  // Daten kombinieren
  let bubbles = bubbleData.map(([word, count]) => {
    const bias = biasData[word];
    const strength = bias ? Math.sqrt(bias.x ** 2 + bias.y ** 2) : 0;
    return { word, count, bias, strength };
  });

  // Filter anwenden
  bubbles = bubbles.filter(({ bias }) => biasPassesFilter(bias));

  // Sortieren
  bubbles.sort((a, b) => {
    switch (sortMode) {
      case "count-asc": return a.count - b.count;
      case "count-desc": return b.count - a.count;
      case "bias-asc": return a.strength - b.strength;
      case "bias-desc":
      default: return b.strength - a.strength;
    }
  });

  renderKeywordScatterChart(bubbles);

  if (filters.keyword) {
    const match = bubbles.find(b => b.word === filters.keyword);
    container.innerHTML = "";

    if (match) {
      renderSingleBubble(match.word, match.count, match.bias);
    } else {
      container.innerHTML = "<p>Kein passendes Bubble-Keyword gefunden.</p>";
    }

    return;
  }



  // Anzeige
  for (const { word, count, bias } of bubbles) {
    const bubble = document.createElement("div");
    bubble.className = "bubble";

    const label = bias
      ? `${word} (${count}) | x: ${bias.x}, y: ${bias.y}`
      : `${word} (${count})`;

    if (bias) {
      bubble.style.backgroundColor = getBiasGradientColor(bias.x, bias.y);
      bubble.style.color = "#fff";
      bubble.title = `x: ${bias.x}, y: ${bias.y}`;
    }

    bubble.textContent = label;
    bubble.onclick = () => {
      container.innerHTML = ""; // Alle anderen Bubbles entfernen
      renderSingleBubble(word, count, bias); // Nur diese Bubble anzeigen
      searchByKeyword(word); // Artikel laden wie gewohnt
    };

    container.appendChild(bubble);
  }
}

function renderSingleBubble(word, count, bias) {
  const container = document.getElementById("extremeKeywordBubbles");
  const bubble = document.createElement("div");
  bubble.className = "bubble";

  const label = bias
    ? `${word} (${count}) | x: ${bias.x}, y: ${bias.y}`
    : `${word} (${count})`;

  if (bias) {
    bubble.style.backgroundColor = getBiasGradientColor(bias.x, bias.y);
    bubble.style.color = "#fff";
    bubble.title = `x: ${bias.x}, y: ${bias.y}`;
  }

  bubble.textContent = label;
  container.appendChild(bubble);
}


function getBiasGradientColor(x, y) {
  const angle = Math.atan2(y, x);
  const hue = ((angle * 180 / Math.PI) + 360) % 360;

  const r = Math.min(Math.sqrt(x * x + y * y), 1); // 0 (zentral) bis 1 (extrem)
  const saturation = Math.round(r * 100);          // 0–100%
  const lightness = 60;                            // optional: 65 - 20 * r

  return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
}






async function loadWordcloud() {
  const qs = new URLSearchParams();
  if (FILTERS.source)  qs.set("source", FILTERS.source);
  if (FILTERS.keyword) qs.set("keyword", FILTERS.keyword);
  if (FILTERS.teaser)  qs.set("teaser", "true");
  if (FILTERS.ngram)   qs.set("ngram", String(FILTERS.ngram));
  const res = await fetch(withTime("/headlines/words", qs.toString()));
  const data = await res.json();

  const words = data
    .filter(([_, count]) => count >= 2)
    .map(([text, count]) => ({ text, count }))
    .sort((a, b) => b.count - a.count); // sortiere nach Häufigkeit absteigend

  d3.select("#wordcloud").html(""); // alte SVG löschen

  let currentWordcloudData = words;

  d3.layout.cloud()
    .spiral("archimedean") // oder "rectangular"
    .size([window.innerWidth, window.innerHeight])
    .words(words)
    .rotate(() => ~~(Math.random() * 2) * 90)
    .font("Impact")
    .fontSize(d => scaleFontSize(d.count))
    .on("end", draw)
    .start();

  function scaleFontSize(count) {
    const minSize = 24;
    const maxSize = 68;

    const counts = currentWordcloudData.map(w => w.count);
    const minCount = Math.min(...counts);
    const maxCount = Math.max(...counts);

    if (maxCount === minCount) return minSize;

    return minSize + ((count - minCount) / (maxCount - minCount)) * (maxSize - minSize);
  }


  function scaleFontWeight(count) {
    const minWeight = 300;
    const maxWeight = 900;

    const counts = currentWordcloudData.map(w => w.count);
    const minCount = Math.min(...counts);
    const maxCount = Math.max(...counts);

    if (maxCount === minCount) return minWeight;

    return minWeight + ((count - minCount) / (maxCount - minCount)) * (maxWeight - minWeight);
  }



  function draw(words) {
    const svg = d3.select("#wordcloud").append("svg")
      .attr("width", window.innerWidth)
      .attr("height", window.innerHeight);

    const g = svg.append("g")
      .attr("transform", `translate(${window.innerWidth / 2},${window.innerHeight / 2})`);

    const texts = g.selectAll("text")
      .data(words)
      .enter().append("text")
      .style("font-size", d => scaleFontSize(d.count) + "px")
      .style("font-family", "Lato")
      .style("fill", () => d3.schemeCategory10[Math.floor(Math.random() * 10)])
      .style("font-weight", d => scaleFontWeight(d.count))
      .attr("text-anchor", "middle")
      .attr("transform", d => `translate(${d.x},${d.y})rotate(${d.rotate})`)
      .text(d => d.text);

    texts.append("title").text(d => `${d.text}: ${d.count}x`);

    texts.on("click", (_, d) => {
      searchByKeyword(d.text);
      loadFilteredMediaCompass(d.text);
      renderKeywordTimeline(d.text);
    });
  }
}




async function loadMediaCompass() {
  const res = await fetch(withTime("/media-positions/filtered"));
  const data = await res.json();
  drawMediaCompass(data, "Medien");
}


function drawMediaCompass(data, label = "Medien") {
  const ctx = document.getElementById("mediaCompassChart").getContext("2d");

  if (mediaCompassChart instanceof Chart) {
    mediaCompassChart.destroy();
  }

  const maxCount = Math.max(...data.map(d => d.count || 1));

  mediaCompassChart = new Chart(ctx, {
    type: "scatter",
    data: {
      datasets: [{
        label: label,
        data: data.map(d => ({
          x: d.x,
          y: d.y,
          label: d.medium,
          count: d.count
        })),
        backgroundColor: "#3b82f6",
        pointRadius: ctx => {
          const count = ctx.raw.count || 1;
          return Math.max(4, count / maxCount * 20);
        }
      }]
    },

    options: {
      onClick: async (evt, elements) => {
        if (elements.length === 0) return;

        const point = elements[0];
        const medium = mediaCompassChart.data.datasets[point.datasetIndex].data[point.index].label;
        filters.source = medium;
        loadFilteredArticles();
        const encodedMedium = encodeURIComponent(medium);

        let url = "";
        if (selectedKeyword) {
          url = withTime("/headlines/by-keyword-and-source", `word=${encodeURIComponent(selectedKeyword)}&source=${encodedMedium}`);
        } else {
          url = withTime("/headlines/by-source", `source=${encodedMedium}`);
        }

        const res = await fetch(url);
        const articles = await res.json();
        renderHeadlineList(articles);
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: ctx => `${ctx.raw.label} (${ctx.raw.count} Artikel)`
          }
        }
      },
      scales: {
        x: {
          min: -1, max: 1,
          title: { display: true, text: "Systemkritisch (–1) → Systemnah (+1)" }
        },
        y: {
          min: -1, max: 1,
          title: { display: true, text: "Nationalistisch (–1) → Globalistisch (+1)" }
        }
      }
    }
  });
}


function resetFilters() {
  const endEx = nowExclusive();
  FILTERS.from = toLocalIsoWithTZ(startOfDay(new Date(endEx.getTime() - 6*86400000)));
  FILTERS.to   = toLocalIsoWithTZ(endEx);
  FILTERS.source=""; FILTERS.keyword=""; FILTERS.teaser=false; FILTERS.ngram=1;

  document.getElementById("sourceSelect").value = "";
  document.getElementById("keywordInput").value = "";
  document.getElementById("teaserToggle").checked = false;

  selectedKeyword = "";
  markActiveDays(7);
  updateDateRangeBadge();
  updateURLFromFilters(false);
  applyFilters();
}



function getSelectedBubbleSort() {
  const select = document.getElementById("bubbleSort");
  return select ? select.value : "bias-desc";
}

function renderKeywordScatterChart(bubbles) {
  const canvas = document.getElementById("keywordScatterChart");
  const ctx = canvas.getContext("2d");

  // 🔧 Kritisch: echte Canvas-Größe setzen!
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;

  const data = bubbles
    .filter(b => b.bias && b.count >= 15)
    .map(b => ({
      x: b.bias.x,
      y: b.bias.y,
      r: Math.min(3 + Math.sqrt(b.count), 15),
      label: b.word,
      count: b.count,
      backgroundColor: b.word === filters.keyword ? "#ef4444" : "#2563eb"
    }));

  if (keywordScatterChart instanceof Chart) {
    keywordScatterChart.destroy();
  }

  keywordScatterChart = new Chart(ctx, {
    type: 'bubble',
    data: {
      datasets: [{
        label: "Keywords",
        data: data.map(d => ({ x: d.x, y: d.y, r: d.r, label: d.label })),
        backgroundColor: data.map(d => d.backgroundColor),
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      onClick: (evt, elements) => {
        if (elements.length === 0) return;
        const point = elements[0];
        const word = keywordScatterChart.data.datasets[0].data[point.index].label;
        loadKeywordDensity(word);
        renderKeywordTimeline(word);
      },
      plugins: {
        tooltip: {
          callbacks: {
            label: (ctx) => {
              const raw = ctx.raw || {};
              // statt r (Radius) die echte Anzahl anzeigen
              const count = raw.count ?? raw.value ?? 0;
              return `Artikel: ${count}`;
            },
          }
        }
      },
      scales: {
        x: {
          min: -1, max: 1,
          title: { display: true, text: "Systemkritisch → Systemnah" }
        },
        y: {
          min: -1, max: 1,
          title: { display: true, text: "Nationalistisch → Globalistisch" }
        }
      }
    }
  });
}

function renderKeywordDensityHeatmap(rawData, keyword = "") {
  const svg = d3.select("#keywordHeatmapOverlay");
  svg.selectAll("*").remove();

  const container = document.getElementById("keywordChartOverlayContainer");
  const rect = container.getBoundingClientRect();
  const width = rect.width;
  const height = rect.height;

  svg
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", `0 0 ${width} ${height}`);

  const xScale = d3.scaleLinear().domain([-1, 1]).range([0, width]);
  const yScale = d3.scaleLinear().domain([-1, 1]).range([height, 0]);

  const points = rawData.flatMap(d => {
    const c = Math.min(30, Math.round(Math.log1p(d.count) * 5));
    if (!isFinite(d.x) || !isFinite(d.y)) return [];
    return Array(c).fill({ x: xScale(d.x), y: yScale(d.y) });
  });

  if (!points.length) {
    console.warn("⚠️ Keine Punkte für Heatmap generiert");
    return;
  }

  const densityData = d3.contourDensity()
    .x(d => d.x)
    .y(d => d.y)
    .size([width, height])
    .bandwidth(50)
    .thresholds(20)(points);

  const color = d3.scaleSequential(d3.interpolateYlOrRd)
    .domain([0, d3.max(densityData, d => d.value)]);

  svg.selectAll("path")
    .data(densityData)
    .join("path")
    .attr("d", d3.geoPath())
    .attr("fill", d => color(d.value))
    .attr("stroke", "#fff")
    .attr("stroke-width", 0.3);
}


async function loadKeywordDensity(keyword) {
  const res = await fetch(withTime("/media-positions/by-keyword", `word=${encodeURIComponent(keyword)}`));
  const data = await res.json();
  renderKeywordDensityHeatmap(data, keyword);
}
async function showKeywordHeatOverlay(keyword) {
  const res = await fetch(withTime("/media-positions/by-keyword", `word=${encodeURIComponent(keyword)}`));
  const heatData = await res.json();
  renderKeywordDensityHeatmap(heatData);
  FILTERS.keyword = keyword;
  selectedKeyword = keyword;
  loadExtremeBubbles();
}

async function loadKeywordDensityMini(keyword) {
  const res = await fetch(withTime("/media-positions/by-keyword",
                   `word=${encodeURIComponent(keyword)}`));
  if (!res.ok) { showMiniEmpty("Fehler beim Laden"); return; }
  const data = await res.json();
  renderKeywordDensityHeatmapIn("keywordHeatMini", "keywordHeatMiniWrap", data);
}

function showMiniEmpty(msg){
  const svg = document.getElementById("keywordHeatMini");
  if (svg) svg.innerHTML = "";
  const ov = document.getElementById("keywordHeatMiniEmpty");
  if (ov){ ov.style.display = "grid"; ov.textContent = msg || "Keine Heatmap-Daten"; }
}
function hideMiniEmpty(){
  const ov = document.getElementById("keywordHeatMiniEmpty");
  if (ov) ov.style.display = "none";
}

function renderKeywordDensityHeatmapIn(svgId, wrapId, rawData){
  const svg = d3.select(`#${svgId}`);
  svg.selectAll("*").remove();

  const wrap = document.getElementById(wrapId);
  if (!wrap || !rawData || !rawData.length){ showMiniEmpty(); return; }
  hideMiniEmpty();

  const width = wrap.clientWidth, height = wrap.clientHeight;
  svg.attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`);

  const xScale = d3.scaleLinear().domain([-1, 1]).range([0, width]);
  const yScale = d3.scaleLinear().domain([-1, 1]).range([height, 0]);

  const points = rawData.flatMap(d => {
    const c = Math.min(30, Math.round(Math.log1p(d.count) * 5));
    if (!Number.isFinite(d.x) || !Number.isFinite(d.y)) return [];
    return Array(c).fill({ x: xScale(d.x), y: yScale(d.y) });
  });
  if (!points.length){ showMiniEmpty(); return; }

  const densityData = d3.contourDensity()
    .x(d => d.x).y(d => d.y)
    .size([width, height]).bandwidth(40).thresholds(16)(points);

  const color = d3.scaleSequential(d3.interpolateYlOrRd)
    .domain([0, d3.max(densityData, d => d.value)]);

  svg.selectAll("path")
    .data(densityData)
    .join("path")
    .attr("d", d3.geoPath())
    .attr("fill", d => color(d.value))
    .attr("stroke", "#fff")
    .attr("stroke-width", 0.3);
}


async function renderKeywordTimeline(keyword) {
  const extra = `word=${encodeURIComponent(keyword)}` + (FILTERS.teaser ? "&teaser=true" : "");
  const res = await fetch(withTime("/keywords/timeline", extra));
  if (!res.ok) return;
  const data = await res.json();

  const chartWrap = document.getElementById('timelineChartWrap');   // <div id="timelineChartWrap"><canvas id="timelineChart"></canvas></div>
  const canvas    = document.getElementById('timelineChart');
  if (!chartWrap || !canvas) return;

  if (!data || data.length === 0 || data.every(p => (p.count||0) === 0)) {
    mountChartEmptyOverlay(chartWrap, "Keine Timeline-Daten im gewählten Zeitraum");
    // Optional: Canvas löschen
    const ctx = canvas.getContext('2d'); ctx.clearRect(0,0,canvas.width,canvas.height);
    return;
  } else {
    hideChartEmptyOverlay(chartWrap);
  }

  const bucket = inferBucketFromTimeline(data);
  const labels = data.map(d => formatTickLabel(d.time, bucket));
  const values = data.map(d => d.count);

  // Falls du Chart.js nutzt:
  if (!window.timelineChart) {
    const ctx = canvas.getContext('2d');
    // Annahme: Chart.js ist eingebunden. Wenn nicht, hier durch eigenen Renderer ersetzen.
    window.timelineChart = new Chart(ctx, {
      type: 'line',
      data: { labels, datasets: [{ label: 'Vorkommen', data: values, tension: 0.25, fill: false }] },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: {
            callbacks: {
              title: (items) => {
                const idx = items[0].dataIndex;
                return labels[idx];
              },
              label: (item) => `Count: ${item.formattedValue}`
            }
          }
        },
        scales: {
          x: { ticks: { autoSkip: true, maxTicksLimit: 10 } },
          y: { beginAtZero: true, ticks: { precision:0 } }
        }
      }
    });
  } else {
    window.timelineChart.data.labels = labels;
    window.timelineChart.data.datasets[0].data = values;
    window.timelineChart.update();
  }
}




async function loadBlindspotFeed() {
  const qs = new URLSearchParams({
    min_total: "5",
    ratio_max: "0.20",
    ngram: String(FILTERS.ngram ?? 1)
  });
  if (FILTERS.teaser) qs.set("teaser", "true");
  const url = withTime("/blindspots/keywords-feed", qs.toString());
  const res = await fetch(url, { cache: "no-store" });
  if (!res.ok) return;
  const data = await res.json();
  renderBlindspotFeed(data);
}


function renderBlindspotFeed(data) {
  const cfg = [
    { key: "systemkritisch",  el: "#feedKritisch",  label: "systemkritisch",  ratioKey: "kritisch" },
    { key: "systemnah",       el: "#feedNah",       label: "systemnah",       ratioKey: "nah" },
    { key: "nationalistisch", el: "#feedNational",  label: "nationalistisch", ratioKey: "national" },
    { key: "globalistisch",   el: "#feedGlobal",    label: "globalistisch",   ratioKey: "global" },
  ];

  for (const { key, el, label, ratioKey } of cfg) {
    const col = document.querySelector(`${el} ul`);
    if (!col) continue;
    col.innerHTML = "";

    const items = data?.items?.[key] || [];
    if (!items.length) {
      const li = document.createElement("li");
      li.className = "empty";
      li.textContent = "— keine Blindspots im Fenster —";
      col.appendChild(li);
      continue;
    }

    for (const it of items) {
      const li = document.createElement("li");
      li.className = "feed-item";

      const btn = document.createElement("button");
      btn.className = "linklike";
      btn.textContent = it.word;
      btn.onclick = () => searchByKeyword(it.word);

      const badge = document.createElement("span");
      badge.className = "blindspot-badge";
      const ratio = Number(it.ratios?.[ratioKey]) || 0;
      const pct   = Math.round(ratio * 100);
      const zero  = it.zero_badge?.[ratioKey] === true;
      badge.textContent = zero ? `0 % ${label}` : `≤ ${pct}% ${label}`;

      const meta = document.createElement("span");
      meta.className = "meta";
      meta.textContent = `(${it.total} Erwähnungen, ${it.sources} Quellen)`;

      li.appendChild(btn);
      li.appendChild(badge);
      li.appendChild(meta);
      col.appendChild(li);
    }
  }
}





    async function loadFilteredMediaCompass() {
      const qs = new URLSearchParams();
      if (FILTERS.source)  qs.set("source", FILTERS.source);
      if (FILTERS.keyword) qs.set("keyword", FILTERS.keyword);
      if (FILTERS.teaser)  qs.set("teaser", "true");
      const res = await fetch(withTime("/media-positions/filtered", qs.toString()));
      const data = await res.json();
      drawMediaCompass(data, "Gefilterte Medien");
    }






    // Event-Listener für die Quellen-Auswahl
    document.getElementById("sourceSelect").addEventListener("change", (e) => {
      filters.source = e.target.value;
      loadFilteredArticles();
      loadExtremeBubbles();
      loadTopAbsoluteKeywords();
      loadFilteredMediaCompass();
      updateFilterDisplay();
      loadBlindspotFeed();
      updateURLFromFilters(false);
    });


    document.getElementById("teaserToggle").addEventListener("change", (e) => {
      filters.teaser = e.target.checked;
      loadFilteredArticles();
      loadKeywordTrends();      // 🔄 aktualisieren
      loadExtremeBubbles();     // 🔄 aktualisieren
      loadWordcloud();
      loadTopAbsoluteKeywords();
      loadFilteredMediaCompass();
      updateFilterDisplay();
      loadBlindspotFeed();
      updateURLFromFilters(false);



    });






/* === Drawer öffnen/schließen === */
const drawer = document.getElementById('filterDrawer');
const scrim  = document.getElementById('scrim');
const btnOpen  = document.getElementById('filterOpen');
const btnClose = document.getElementById('drawerClose');
const btnDone  = document.getElementById('drawerDone');

function openDrawer(){
  drawer.classList.add('open'); drawer.setAttribute('aria-hidden','false');
  scrim.classList.add('show');  scrim.setAttribute('aria-hidden','false');
}
function closeDrawer(){
  drawer.classList.remove('open'); drawer.setAttribute('aria-hidden','true');
  scrim.classList.remove('show');  scrim.setAttribute('aria-hidden','true');
}
btnOpen.addEventListener('click', openDrawer);
btnClose.addEventListener('click', closeDrawer);
btnDone.addEventListener('click', closeDrawer);
scrim.addEventListener('click', closeDrawer);

/* === Aktive Filter: Chips darstellen === */
function renderActiveFilterChips(){
  const bar = document.getElementById('activeFiltersBar');
  if (!bar) return;
  bar.innerHTML = ''; // reset

  // Helper zum Erstellen eines Chips
  const mk = (label, onRemove, {removable=true, ghost=false} = {})=>{
    const pill = document.createElement('span');
    pill.className = 'pill' + (ghost ? ' pill--ghost' : '');
    pill.textContent = label;

    if (removable){
      const x = document.createElement('button');
      x.className = 'pill-x';
      x.type = 'button';
      x.setAttribute('aria-label', label + ' entfernen');
      x.textContent = '×';
      x.onclick = onRemove;
      pill.appendChild(x);
    }
    bar.appendChild(pill);
  };

  // Zeitfenster (ganze Tage)
  if (FILTERS.from && FILTERS.to) {
    const f = new Date(FILTERS.from);
    const t = new Date(new Date(FILTERS.to).getTime() - 1);
    const fmt = new Intl.DateTimeFormat('de-DE', { day:'2-digit', month:'2-digit', year:'2-digit' });
    mk(`📅 ${fmt.format(f)} – ${fmt.format(t)}`, () => {
      const today = new Date();
      FILTERS.from = toLocalIsoWithTZ(startOfDay(new Date(today.getTime() - 6*86400000)));
      FILTERS.to   = toLocalIsoWithTZ(endOfDayExclusive(today));
      markActiveDays(7);
      updateDateRangeBadge();
      updateURLFromFilters(false);
      applyFilters();
    });
  }

  // Quelle
  if (filters.source){
    mk(`📰 ${filters.source}`, () => {
      filters.source = '';
      const sel = document.getElementById('sourceSelect'); if (sel) sel.value = '';
      loadFilteredArticles();
      loadExtremeBubbles();
      loadTopAbsoluteKeywords();
      loadFilteredMediaCompass();
      loadBlindspotFeed();
      updateURLFromFilters(false);
      renderActiveFilterChips();
    });
  } else {
    mk('📰 Alle Quellen', null, { removable:false, ghost:true });
  }

  // Keyword
  if (filters.keyword){
    mk(`🔍 ${filters.keyword}`, () => {
      filters.keyword = '';
      if (typeof selectedKeyword !== 'undefined') selectedKeyword = '';
      const inp = document.getElementById('keywordInput'); if (inp) inp.value = '';
      loadFilteredArticles();
      loadExtremeBubbles();
      loadTopAbsoluteKeywords();
      loadFilteredMediaCompass();
      loadBlindspotFeed();
      updateURLFromFilters(false);
      renderActiveFilterChips();
    });
  }

  // Teaser
  if (filters.teaser){
    mk('📝 Teaser', () => {
      filters.teaser = false;
      const cb = document.getElementById('teaserToggle'); if (cb) cb.checked = false;
      loadFilteredArticles();
      loadExtremeBubbles();
      loadTopAbsoluteKeywords();
      loadFilteredMediaCompass();
      renderActiveFilterChips();
      loadBlindspotFeed();
    });
  }

  // Ngram
  if (filters.ngram && filters.ngram !== 1){
    const label = filters.ngram === 2 ? '🔗 2er-Kombis' : '🔗 3er-Kombis';
    mk(label, () => {
      filters.ngram = 1;
      loadWordcloud();
      loadFilteredMediaCompass();
      renderActiveFilterChips();
    });
  }


  // Alle löschen (schneller Reset)
  const dPreset = presetDaysFromRange();
  if (filters.source || filters.keyword || filters.teaser || dPreset !== 7){
    const all = document.createElement('button');
    all.className = 'pill';
    all.type = 'button';
    all.textContent = 'Alle ×';
    all.onclick = () => resetFilters(); // deine bestehende Funktion
    bar.appendChild(all);
  }
}

/* === Bestehende Anzeige-Funktion an neue Chips binden === */
const _updateFilterDisplay = window.updateFilterDisplay || (()=>{});
window.updateFilterDisplay = function(){
  // Alte Textanzeige (falls noch vorhanden) aktualisieren
  try { _updateFilterDisplay(); } catch {}
  // Neue Chips rendern
  renderActiveFilterChips();
};

/* === Nach Initialisierung & bei Filter-Events Chips aktualisieren === */
window.addEventListener('load', renderActiveFilterChips);

// Falls du setTimeFilter / resetFilters überschreibst, Chips dort erneut rendern:
// Beispiel (optional), nur wenn du sie "wrappen" möchtest:
/*
const _setTimeFilter = window.setTimeFilter;
window.setTimeFilter = function(h){
  _setTimeFilter(h);
  renderActiveFilterChips();
};
const _resetFilters = window.resetFilters;
window.resetFilters = function(){
  _resetFilters();
  renderActiveFilterChips();
};
*/

const dayBtns = Array.from(document.querySelectorAll('.time-presets [data-days]'));

function markActiveDays(d) {
  dayBtns.forEach(b => b.classList.remove('is-active'));
  const btn = dayBtns.find(b => parseInt(b.getAttribute('data-days'),10) === Number(d));
  if (btn) btn.classList.add('is-active');
}

document.addEventListener('click', (e) => {
  const btn = e.target.closest('.time-presets [data-days]');
  if (!btn) return;
  const days = parseInt(btn.getAttribute('data-days'), 10);
  if (Number.isNaN(days)) return;
  onPresetDaysClick(days);
}, true);

function onPresetDaysClick(days){
  const endEx = nowExclusive(); // JETZT (exklusiv)
  const start = startOfDay(new Date(endEx.getTime() - days*86400000));

  FILTERS.from = toLocalIsoWithTZ(start);
  FILTERS.to   = toLocalIsoWithTZ(endEx);

  markActiveDays(days);
  updateDateRangeBadge();
  updateURLFromFilters(false);
  applyFilters();
}



// Bias-Buttons markieren
const biasBtns = Array.from(document.querySelectorAll('#biasFilters button'));
function markActiveBias(nameOrNull){
  biasBtns.forEach(b => b.classList.remove('is-active'));
  let label = 'Alle';
  if (nameOrNull === 'systemkritisch') label = 'Systemkritisch';
  else if (nameOrNull === 'systemnah')  label = 'Systemnah';
  else if (nameOrNull === 'globalistisch') label = 'Globalistisch';
  else if (nameOrNull === 'nationalistisch') label = 'Nationalistisch';
  const btn = biasBtns.find(b => b.textContent.trim() === label);
  if (btn) btn.classList.add('is-active');
}
const _setBiasFilter = window.setBiasFilter;
window.setBiasFilter = function(name){
  _setBiasFilter(name);
  markActiveBias(name || null);
};

// Initiale Markierung (nach load)
window.addEventListener('load', () => {
  const d = presetDaysFromRange();   // ermittelt 1/3/7/30 aus from/to, sonst null
  if (d) markActiveDays(d);
  markActiveBias(window.activeBiasFilter || null);
});


  function inferBucketFromTimeline(data){
    // Nimmt Timeline-Daten [{time, count}] und erkennt hour/day/week
    if (!data || data.length < 2) return "hour";
    const a = new Date(data[0].time).getTime();
    const b = new Date(data[1].time).getTime();
    const diffH = Math.round((b - a) / 3_600_000);
    if (diffH === 1) return "hour";
    if (diffH >= 24*7) return "week";
    if (diffH >= 24) return "day";
    return "hour";
  }

  function formatTickLabel(iso, bucket){
    const d = new Date(iso);
    if (bucket === "hour") {
      const df = new Intl.DateTimeFormat('de-DE',{day:'2-digit',month:'2-digit'});
      const tf = new Intl.DateTimeFormat('de-DE',{hour:'2-digit'});
      return `${df.format(d)} ${tf.format(d)}h`;
    }
    if (bucket === "day") {
      return new Intl.DateTimeFormat('de-DE',{weekday:'short', day:'2-digit', month:'2-digit'}).format(d);
    }
    if (bucket === "week") {
      // Kalenderwoche grob als Montagsdatum anzeigen
      return "KW " + weekOfYear(d);
    }
    return new Intl.DateTimeFormat('de-DE').format(d);
  }

  function weekOfYear(date){
    // ISO-Woche (Mo-So)
    const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
    const dayNum = (d.getUTCDay() + 6) % 7; // 0=Mo
    d.setUTCDate(d.getUTCDate() - dayNum + 3);
    const firstThursday = new Date(Date.UTC(d.getUTCFullYear(),0,4));
    const week = 1 + Math.round(((d - firstThursday) / 86400000 - 3 + ((firstThursday.getUTCDay() + 6) % 7)) / 7);
    return week;
  }

  // --- H: Empty-State Helpers -------------------------------------------------
  function showEmptyState(container, message, hint){
    if (!container) return;
    container.innerHTML = `
      <div class="empty-state">
        ${message}
        ${hint ? `<span class="hint">${hint}</span>` : ""}
      </div>`;
  }
  function clearEmptyState(container){
    if (!container) return;
    container.innerHTML = "";
  }

  // Für Charts: Overlay auf einem umschließenden Relativ-Container
  function mountChartEmptyOverlay(container, text="Keine Daten im gewählten Zeitraum"){
    if (!container) return;
    container.style.position = container.style.position || "relative";
    let overlay = container.querySelector('.chart-overlay-empty');
    if (!overlay){
      overlay = document.createElement('div');
      overlay.className = 'chart-overlay-empty';
      overlay.textContent = text;
      container.appendChild(overlay);
    } else {
      overlay.style.display = 'grid';
      overlay.textContent = text;
    }
  }
  function hideChartEmptyOverlay(container){
    const ov = container?.querySelector?.('.chart-overlay-empty');
    if (ov) ov.style.display = 'none';
  }



  function presetDaysFromRange() {
    if (!(FILTERS.from && FILTERS.to)) return null;
    const n = Math.round((new Date(FILTERS.to) - new Date(FILTERS.from)) / 86400000);
    return [1,3,7,30].includes(n) ? n : null;
  }

  // 1) ganz oben irgendwo nach den Preset-Funktionen:
  window.addEventListener('load', () => {
    const d = presetDaysFromRange();
    if (d) markActiveDays(d);
  });

  // 2) und weiter unten bei der kombinierten Initial-Markierung:
  window.addEventListener('load', () => {
    const d = presetDaysFromRange();
    if (d) markActiveDays(d);
    markActiveBias(window.activeBiasFilter || null);
  });





  function formatBadgeLabel(fromIso, toIso) {
    try {
      const f = new Date(fromIso);
      const t = new Date(new Date(toIso).getTime() - 1);
      const df = new Intl.DateTimeFormat('de-DE',{day:'2-digit',month:'2-digit',year:'2-digit'});
      return `${(window.DATE_RANGE_SPEC?.I18N?.badgePrefix)||'📅'} ${df.format(f)} – ${df.format(t)}`;
    } catch { return `${(window.DATE_RANGE_SPEC?.I18N?.badgePrefix)||'📅'} benutzerdefiniert`; }
  }

  function updateDateRangeBadge() {
    const el = document.getElementById('date-range-badge');
    if (!el) return;
    if (FILTERS.from && FILTERS.to) {
      el.style.display = 'inline-flex';
      const label = el.querySelector('.label');
      if (label) label.textContent = formatBadgeLabel(FILTERS.from, FILTERS.to);
    } else {
      el.style.display = 'none';
    }
  }

  document.addEventListener('click', (e) => {
    const rm = e.target.closest('#date-range-badge .remove');
    if (!rm) return;
    const endEx = nowExclusive();
    FILTERS.from = toLocalIsoWithTZ(startOfDay(new Date(endEx.getTime() - 6*86400000)));
    FILTERS.to   = toLocalIsoWithTZ(endEx);
    markActiveDays(7);
    updateDateRangeBadge();
    updateURLFromFilters(false);
    applyFilters();
  }, true);



  // ---- APPLY FILTERS: ALLE FETCHES SYNCHRON MIT from/to ODER hours ----------
  // Suche in deinem Code alle Stellen, wo URLs gebaut werden, und hänge buildTimeQuery() an.
  // Unten zwei typische Beispiele; passe sie an deine tatsächlichen Funktionen an.

  async function fetchFilteredArticles() {
    const base = '/articles/filtered';
    const time = buildTimeQuery();
    const qs = new URLSearchParams();
    if (FILTERS.source)  qs.set('source', FILTERS.source);
    if (FILTERS.keyword) qs.set('keyword', FILTERS.keyword);
    if (FILTERS.teaser)  qs.set('teaser', '1');
    const url = `${base}?${time}${qs.toString() ? '&' + qs.toString() : ''}`;
    const res = await fetch(url);
    return res.json();
  }

  async function fetchKeywordTimeline(word) {
    const base = '/keywords/timeline';
    const time = buildTimeQuery();
    const qs = new URLSearchParams({ word });
    // Optional: bucket=auto|hour|day|week (Standard: auto)
    // qs.set('bucket', 'auto');
    const url = `${base}?${time}&${qs.toString()}`;
    const res = await fetch(url);
    return res.json();
  }



  // --- G: Flatpickr Range-Picker mit Uhrzeit ---------------------------------
  let fp = null;

  function openCustomRangeModal() {
    const modal = document.getElementById('customRangeModal');
    modal.style.display = 'flex';
    modal.setAttribute('aria-hidden', 'false');
    modal.setAttribute('aria-modal', 'true');
    // Fokus in das Eingabefeld
    setTimeout(() => document.getElementById('fpRange').focus(), 0);
  }

  function closeCustomRangeModal() {
    const modal = document.getElementById('customRangeModal');
    modal.style.display = 'none';
    modal.setAttribute('aria-hidden', 'true');
    modal.setAttribute('aria-modal', 'false');
    document.getElementById('btnCustomRange').focus();
  }


  function startOfDay(d) {
    const x = new Date(d);
    x.setHours(0,0,0,0);
    return x;
  }
  function endOfDayExclusive(d) {
    // exklusives Ende: 00:00 des FOLGETAGES
    const x = new Date(d);
    x.setHours(0,0,0,0);
    x.setDate(x.getDate() + 1);
    return x;
  }
  function toLocalIsoWithTZ(d) {
    const pad = n => String(n).padStart(2,'0');
    const offMin = -d.getTimezoneOffset();
    const sign = offMin >= 0 ? '+' : '-';
    const hh = pad(Math.floor(Math.abs(offMin)/60));
    const mm = pad(Math.abs(offMin)%60);
    return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}${sign}${hh}:${mm}`;
  }

  // Liefert "jetzt" als exklusive Obergrenze (Sekunden=00 für Konsistenz)
  function nowExclusive(){
    const n = new Date();
    n.setSeconds(0, 0);
    return n;
  }

  // Klemmt einen [from, to)-Bereich so, dass 'to' niemals in der Zukunft liegt.
  // Gibt {from:Date, to:Date} zurück (beide lokale Date-Objekte).
  function clampRangeToNow(fromDate, toDate){
    const now = nowExclusive();
    // to darf nicht in der Zukunft liegen
    const toClamped = (toDate > now) ? now : toDate;
    // und muss strikt > from bleiben (sonst min. +1 Minute)
    const minTo = new Date(fromDate.getTime() + 60*1000);
    return {
      from: fromDate,
      to: (toClamped <= fromDate) ? minTo : toClamped
    };
  }

  // Max-Range aus Spec holen (Fallback 180 Tage)
  function getMaxRangeDays() {
    return (window.DATE_RANGE_SPEC?.MAX_RANGE_DAYS ?? 180);
  }

  // Validierung: [from, to) und Max-Range
  function validateRange(fDate, tDate) {
    if (!fDate || !tDate) return { ok:false, msg: "Bitte Start und Ende wählen." };
    if (tDate <= fDate)   return { ok:false, msg: "Ende muss nach Start liegen." };
    const maxDays = getMaxRangeDays();
    const diffDays = (tDate - fDate) / (1000 * 60 * 60 * 24);
    if (diffDays > maxDays) return { ok:false, msg: `Zeitraum zu groß (max. ${maxDays} Tage).` };
    const now = new Date();
    if (fDate > now || tDate > now) return { ok:false, msg: "Zeiten in der Zukunft sind nicht erlaubt." };
    return { ok:true };
  }

function initFlatpickr() {
  const input = document.getElementById('fpRange');
  if (!input) return;

  if (window.flatpickr && window.flatpickr.l10ns && window.flatpickr.l10ns.de) {
    flatpickr.localize(flatpickr.l10ns.de);
  }

  fp = flatpickr(input, {
    mode: "range",
    enableTime: false,          // <— KEINE Uhrzeit
    time_24hr: true,            // egal, da keine Zeit
    altInput: true,
    altFormat: "d.m.Y",
    dateFormat: "Y-m-d",        // nur Datum
    defaultDate: (() => {
      if (FILTERS.from && FILTERS.to) {
        // FILTERS.to ist exklusiv -> -1 Tag für Anzeige
        const f = startOfDay(new Date(FILTERS.from));
        const tExclusive = new Date(FILTERS.to);
        const tDisplay = new Date(tExclusive.getTime() - 1); // 1ms zurück in den Vortag
        return [f, tDisplay];
      }
      // Fallback: letzte 7 Tage inkl. heute
      const today = new Date();
      const from  = startOfDay(new Date(today.getTime() - 6*86400000));
      return [from, today];
    })(),
    maxDate: new Date(),
    onOpen: () => {
      if (FILTERS.from && FILTERS.to) {
        const f = startOfDay(new Date(FILTERS.from));
        const tDisplay = new Date(new Date(FILTERS.to).getTime() - 1);
        fp.setDate([f, tDisplay], false);
      }
    }
  });
}

// Modal-Buttons
document.addEventListener('click', (e) => {
  if (e.target.matches('#btnCustomRange')) {
    e.preventDefault();
    openCustomRangeModal();
    if (!fp) initFlatpickr();
  }
  if (e.target.matches('#btnRangeClose') || e.target.matches('#btnRangeCancel')) {
    e.preventDefault();
    closeCustomRangeModal();
  }
  // … innerhalb deines Click-Handlers für #btnRangeApply:
  if (e.target.matches('#btnRangeApply')) {
    e.preventDefault();
    if (!fp) { closeCustomRangeModal(); return; }
    const sel = fp.selectedDates || [];
    if (sel.length < 2) { alert("Bitte Start und Ende wählen."); return; }

    const f = startOfDay(sel[0]);
    const chosenEndExclusive = endOfDayExclusive(sel[1]); // 00:00 Folgetag
    const endEx = nowExclusive();
    const toEx  = (chosenEndExclusive > endEx) ? endEx : chosenEndExclusive;

    if (toEx <= f) { alert("Ende muss nach Start liegen."); return; }

    FILTERS.from = toLocalIsoWithTZ(f);
    FILTERS.to   = toLocalIsoWithTZ(toEx);

    const cb = document.getElementById('cbIncludeTeaserInRange');
    if (cb) FILTERS.teaser = !!cb.checked;

    markActiveDays(null);
    updateDateRangeBadge();
    updateURLFromFilters(false);
    applyFilters();
    closeCustomRangeModal();
  }

}, true);


// ESC schließt Modal
document.addEventListener('keydown', (e) => {
  const modal = document.getElementById('customRangeModal');
  if (modal?.style.display === 'flex' && e.key === 'Escape') {
    closeCustomRangeModal();
  }
});

// Bei erstem Load Picker vorbereiten (nicht öffnen)
window.addEventListener('DOMContentLoaded', () => {
  // Nur initialisieren, wenn du willst dass der Picker sofort bereit ist:
  // initFlatpickr();
});


  </script>
</body>
</html>
